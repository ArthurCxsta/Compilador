/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.5). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%define api.pure
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the bnfc_grupo_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE bnfc_grupo__scan_string(const char *str, yyscan_t scanner);
extern void bnfc_grupo__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void bnfc_grupo_lex_destroy(yyscan_t scanner);
extern char* bnfc_grupo_get_text(yyscan_t scanner);

extern yyscan_t bnfc_grupo__initialize_lexer(FILE * inp);

/* List reversal functions. */

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Programs programs_;
  Declaracoes declaracoes_;
  Declaracao declaracao_;
  StructDecl structdecl_;
  FieldDecl fielddecl_;
  PonteiraDecl ponteiradecl_;
  VetorDecl vetordecl_;
  Instrucoes instrucoes_;
  Instrucao instrucao_;
  Atribuicao atribuicao_;
  Comentario comentario_;
  DeclaracaoSe declaracaose_;
  LoopPara looppara_;
  Imprima imprima_;
  Entrada entrada_;
  Modularizacao modularizacao_;
  Expressao expressao_;
  Termo termo_;
  Condicao condicao_;
  Tipo tipo_;
  Identificador identificador_;
  Inteiro inteiro_;
  Real real_;
  Chax chax_;
  Texto texto_;
  IdentifierLabel identifierlabel_;
  TypeType typetype_;
  Letra letra_;
  Digito digito_;
  Caractere caractere_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, bnfc_grupo_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _LPAREN            /* ( */
%token          _SYMB_18           /* (Letra */
%token          _RPAREN            /* ) */
%token          _STAR              /* * */
%token          _PLUS              /* + */
%token          _MINUS             /* - */
%token          _DOT               /* . */
%token          _SLASH             /* / */
%token          _DSLASH            /* // */
%token          _SEMI              /* ; */
%token          _LT                /* < */
%token          _LDARROW           /* <= */
%token          _EQ                /* = */
%token          _DEQ               /* == */
%token          _GT                /* > */
%token          _GTEQ              /* >= */
%token          _SYMB_21           /* Caractere* */
%token          _KW_Digito         /* Digito */
%token          _KW_SE             /* SE */
%token          _LBRACK            /* [ */
%token          _SYMB_23           /* [0-9] */
%token          _SYMB_24           /* [a-zA-Z0-9 */
%token          _SYMB_22           /* [a-zA-Z] */
%token          _RBRACK            /* ] */
%token          _KW_e              /* e */
%token          _KW_entrada        /* entrada */
%token          _KW_imprima        /* imprima */
%token          _KW_int            /* int */
%token          _KW_modularizacao  /* modularizacao */
%token          _KW_nao            /* nao */
%token          _KW_ou             /* ou */
%token          _KW_para           /* para */
%token          _KW_principal      /* principal */
%token          _KW_retorne        /* retorne */
%token          _KW_senao          /* senao */
%token          _KW_struct         /* struct */
%token          _KW_texto          /* texto */
%token          _LBRACE            /* { */
%token          _BAR               /* | */
%token          _RBRACE            /* } */
%token<_string> _STRING_
%token<_char>   _CHAR_

%type <programs_> Programs
%type <declaracoes_> Declaracoes
%type <declaracao_> Declaracao
%type <structdecl_> StructDecl
%type <fielddecl_> FieldDecl
%type <ponteiradecl_> PonteiraDecl
%type <vetordecl_> VetorDecl
%type <instrucoes_> Instrucoes
%type <instrucao_> Instrucao
%type <atribuicao_> Atribuicao
%type <comentario_> Comentario
%type <declaracaose_> DeclaracaoSe
%type <looppara_> LoopPara
%type <imprima_> Imprima
%type <entrada_> Entrada
%type <modularizacao_> Modularizacao
%type <expressao_> Expressao
%type <termo_> Termo
%type <condicao_> Condicao
%type <tipo_> Tipo
%type <identificador_> Identificador
%type <inteiro_> Inteiro
%type <real_> Real
%type <chax_> Chax
%type <texto_> Texto
%type <identifierlabel_> IdentifierLabel
%type <typetype_> TypeType1
%type <typetype_> TypeType2
%type <typetype_> TypeType3
%type <letra_> Letra
%type <digito_> Digito
%type <caractere_> Caractere

%start Programs

%%

Programs : _KW_int _KW_principal _LPAREN _RPAREN _LBRACE Declaracoes Instrucoes _KW_retorne Inteiro _SEMI _RBRACE _SEMI { $$ = make_Label1($6, $7, $9); };
Declaracoes : Declaracao Declaracoes _SEMI { $$ = make_Declaracoes1($1, $2); };
Declaracao : Tipo Identificador _SEMI { $$ = make_Declaracao1($1, $2); }
  | StructDecl _SEMI { $$ = make_Declaracao2($1); }
  | PonteiraDecl _SEMI { $$ = make_Declaracao3($1); }
  | VetorDecl _SEMI { $$ = make_Declaracao4($1); }
  | Tipo Identificador _EQ Inteiro _SEMI { $$ = make_Declaracao5($1, $2, $4); }
  | Tipo Identificador _EQ Real _SEMI { $$ = make_Declaracao6($1, $2, $4); }
  | Tipo Identificador _EQ _CHAR_ _SEMI { $$ = make_Declaracao7($1, $2, $4); }
  | Tipo Identificador _EQ _STRING_ _SEMI { $$ = make_Declaracao8($1, $2, $4); }
  | StructDecl _SEMI { $$ = make_Declaracao9($1); }
  | PonteiraDecl _SEMI { $$ = make_Declaracao10($1); }
  | VetorDecl _SEMI { $$ = make_Declaracao11($1); }
;
StructDecl : _KW_struct IdentifierLabel _LBRACE FieldDecl _RBRACE _SEMI { $$ = make_E($2, $4); }
;
FieldDecl : TypeType1 IdentifierLabel _SEMI { $$ = make_F($1, $2); }
;
PonteiraDecl : TypeType2 _STAR IdentifierLabel _SEMI { $$ = make_P($1, $3); }
;
VetorDecl : TypeType3 IdentifierLabel _LBRACK Inteiro _RBRACK _SEMI { $$ = make_V($1, $2, $4); }
;
Instrucoes : Instrucao Instrucoes _SEMI { $$ = make_Instrucoes1($1, $2); }
;
Instrucao : Atribuicao _SEMI { $$ = make_Instrucao1($1); }
  | Modularizacao _SEMI { $$ = make_Instrucao2($1); }
;
Atribuicao : Identificador _EQ Expressao _SEMI { $$ = make_A($1, $3); }
;
Comentario : _DSLASH _STRING_ _SEMI { $$ = make_Co($2); }
;
DeclaracaoSe : _KW_SE _LPAREN Expressao _RPAREN _LBRACE Instrucoes _RBRACE _KW_senao _LBRACE Instrucoes _RBRACE _SEMI { $$ = make_Label2($3, $6, $10); }
;
LoopPara : _KW_para _LPAREN Atribuicao _SEMI Condicao _SEMI Atribuicao _RPAREN _LBRACE Instrucoes _RBRACE _SEMI { $$ = make_Label3($3, $5, $7, $10); }
;
Imprima : _KW_imprima _LPAREN Expressao _RPAREN _SEMI { $$ = make_Label4($3); }
;
Entrada : _KW_entrada _LPAREN Identificador _RPAREN _SEMI { $$ = make_Label5($3); }
;
Modularizacao : _KW_modularizacao IdentifierLabel _LPAREN _RPAREN _LBRACE Instrucoes _RBRACE _SEMI { $$ = make_Label6($2, $6); }
;
Expressao : Termo _SEMI { $$ = make_Expressao1($1); }
  | Expressao _PLUS Termo _SEMI { $$ = make_Expressao2($1, $3); }
  | Expressao _MINUS Termo _SEMI { $$ = make_Expressao3($1, $3); }
  | Expressao _STAR Termo _SEMI { $$ = make_Expressao4($1, $3); }
  | Expressao _SLASH Termo _SEMI { $$ = make_Expressao5($1, $3); }
;
Termo : Identificador _SEMI { $$ = make_Termo1($1); }
  | Identificador _LBRACK Inteiro _RBRACK _SEMI { $$ = make_Termo2($1, $3); }
  | Inteiro { $$ = make_TermoInteiro($1); }
  | Texto { $$ = make_TermoTexto($1); }
  | Identificador _LBRACK Inteiro _RBRACK _SEMI { $$ = make_Termo3($1, $3); }
;
Condicao : Expressao _GT Expressao _SEMI { $$ = make_Condicao1($1, $3); }
  | Expressao _GTEQ Expressao _SEMI { $$ = make_Condicao2($1, $3); }
  | Expressao _LT Expressao _SEMI { $$ = make_Condicao3($1, $3); }
  | Expressao _LDARROW Expressao _SEMI { $$ = make_Condicao4($1, $3); }
  | Expressao _DEQ Expressao _SEMI { $$ = make_Condicao5($1, $3); }
  | _KW_nao Condicao _SEMI { $$ = make_Condicao6($2); }
  | _LPAREN Condicao _RPAREN _SEMI { $$ = make_Condicao7($2); }
  | Condicao _KW_e Condicao _SEMI { $$ = make_Condicao8($1, $3); }
  | Condicao _KW_ou Condicao _SEMI { $$ = make_Condicao9($1, $3); }
;
Tipo : _KW_int { $$ = make_Tipo_int(); }
  | _KW_texto { $$ = make_Tipo_texto(); }
  | _KW_struct IdentifierLabel _SEMI { $$ = make_Tipo1($2); }
;
Identificador : Letra _SYMB_18 _BAR _KW_Digito _RPAREN _SEMI { $$ = make_Id($1); }
;
Inteiro : Digito _SEMI { $$ = make_In($1); }
;
Real : Digito _DOT Digito _SEMI { $$ = make_Ir($1, $3); }
;
Chax : Letra _SEMI { $$ = make_Ch($1); }
;
Texto : _SYMB_21 _SEMI { $$ = make_It(); }
;
IdentifierLabel : Identificador { $$ = make_Ie($1); }
;
TypeType1 : _KW_int _SEMI { $$ = make_TypeType11(); }
  | _KW_texto _SEMI { $$ = make_TypeType12(); }
  | _KW_struct IdentifierLabel _SEMI { $$ = make_TypeType13($2); }
;
TypeType2 : _KW_int _SEMI { $$ = make_TypeType21(); }
  | _KW_texto _SEMI { $$ = make_TypeType22(); }
  | _KW_struct IdentifierLabel _SEMI { $$ = make_TypeType23($2); }
;
TypeType3 : _KW_int _SEMI { $$ = make_TypeType31(); }
  | _KW_texto _SEMI { $$ = make_TypeType32(); }
  | _KW_struct IdentifierLabel _SEMI { $$ = make_TypeType33($2); }
;
Letra : _SYMB_22 _SEMI { $$ = make_L(); }
;
Digito : _SYMB_23 _SEMI { $$ = make_D(); }
;
Caractere : _SYMB_24 _RBRACK _SEMI { $$ = make_Ca(); }
;

%%


/* Entrypoint: parse Programs from file. */
Programs pPrograms(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = bnfc_grupo__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  bnfc_grupo_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.programs_;
  }
}

/* Entrypoint: parse Programs from string. */
Programs ps(Programsconst char *str)
{
  YYSTYPE result;
  yyscan_t scanner = bnfc_grupo__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = bnfc_grupo__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  bnfc_grupo__delete_buffer(buf, scanner);
  bnfc_grupo_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.programs_;
  }
}



