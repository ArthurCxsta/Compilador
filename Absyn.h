/* File generated by the BNF Converter (bnfc 2.9.5). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;

/********************   Forward Declarations    ***********************/
struct Programs_;
typedef struct Programs_ *Programs;

struct Declaracoes_;
typedef struct Declaracoes_ *Declaracoes;

struct Declaracao_;
typedef struct Declaracao_ *Declaracao;

struct StructDecl_;
typedef struct StructDecl_ *StructDecl;

struct FieldDecl_;
typedef struct FieldDecl_ *FieldDecl;

struct PonteiraDecl_;
typedef struct PonteiraDecl_ *PonteiraDecl;

struct VetorDecl_;
typedef struct VetorDecl_ *VetorDecl;

struct Instrucoes_;
typedef struct Instrucoes_ *Instrucoes;

struct Instrucao_;
typedef struct Instrucao_ *Instrucao;

struct Atribuicao_;
typedef struct Atribuicao_ *Atribuicao;

struct Comentario_;
typedef struct Comentario_ *Comentario;

struct DeclaracaoSe_;
typedef struct DeclaracaoSe_ *DeclaracaoSe;

struct LoopPara_;
typedef struct LoopPara_ *LoopPara;

struct Imprima_;
typedef struct Imprima_ *Imprima;

struct Entrada_;
typedef struct Entrada_ *Entrada;

struct Modularizacao_;
typedef struct Modularizacao_ *Modularizacao;

struct Expressao_;
typedef struct Expressao_ *Expressao;

struct Termo_;
typedef struct Termo_ *Termo;

struct Condicao_;
typedef struct Condicao_ *Condicao;

struct Tipo_;
typedef struct Tipo_ *Tipo;

struct Identificador_;
typedef struct Identificador_ *Identificador;

struct Inteiro_;
typedef struct Inteiro_ *Inteiro;

struct Real_;
typedef struct Real_ *Real;

struct Chax_;
typedef struct Chax_ *Chax;

struct Texto_;
typedef struct Texto_ *Texto;

struct IdentifierLabel_;
typedef struct IdentifierLabel_ *IdentifierLabel;

struct TypeType_;
typedef struct TypeType_ *TypeType;

struct Letra_;
typedef struct Letra_ *Letra;

struct Digito_;
typedef struct Digito_ *Digito;

struct Caractere_;
typedef struct Caractere_ *Caractere;

/********************   Abstract Syntax Classes    ********************/

struct Programs_
{
  enum { is_Label1 } kind;
  union
  {
    struct { Declaracoes declaracoes_; Instrucoes instrucoes_; Inteiro inteiro_; } label1_;
  } u;
};

Programs make_Label1(Declaracoes p0, Instrucoes p1, Inteiro p2);

struct Declaracoes_
{
  enum { is_Declaracoes1 } kind;
  union
  {
    struct { Declaracao declaracao_; Declaracoes declaracoes_; } declaracoes1_;
  } u;
};

Declaracoes make_Declaracoes1(Declaracao p0, Declaracoes p1);

struct Declaracao_
{
  enum { is_Declaracao1, is_Declaracao2, is_Declaracao3, is_Declaracao4, is_Declaracao5, is_Declaracao6, is_Declaracao7, is_Declaracao8, is_Declaracao9, is_Declaracao10, is_Declaracao11 } kind;
  union
  {
    struct { Identificador identificador_; Tipo tipo_; } declaracao1_;
    struct { StructDecl structdecl_; } declaracao2_;
    struct { PonteiraDecl ponteiradecl_; } declaracao3_;
    struct { VetorDecl vetordecl_; } declaracao4_;
    struct { Identificador identificador_; Inteiro inteiro_; Tipo tipo_; } declaracao5_;
    struct { Identificador identificador_; Real real_; Tipo tipo_; } declaracao6_;
    struct { Char char_; Identificador identificador_; Tipo tipo_; } declaracao7_;
    struct { Identificador identificador_; String string_; Tipo tipo_; } declaracao8_;
    struct { StructDecl structdecl_; } declaracao9_;
    struct { PonteiraDecl ponteiradecl_; } declaracao10_;
    struct { VetorDecl vetordecl_; } declaracao11_;
  } u;
};

Declaracao make_Declaracao1(Tipo p0, Identificador p1);
Declaracao make_Declaracao2(StructDecl p0);
Declaracao make_Declaracao3(PonteiraDecl p0);
Declaracao make_Declaracao4(VetorDecl p0);
Declaracao make_Declaracao5(Tipo p0, Identificador p1, Inteiro p2);
Declaracao make_Declaracao6(Tipo p0, Identificador p1, Real p2);
Declaracao make_Declaracao7(Tipo p0, Identificador p1, Char p2);
Declaracao make_Declaracao8(Tipo p0, Identificador p1, String p2);
Declaracao make_Declaracao9(StructDecl p0);
Declaracao make_Declaracao10(PonteiraDecl p0);
Declaracao make_Declaracao11(VetorDecl p0);

struct StructDecl_
{
  enum { is_E } kind;
  union
  {
    struct { FieldDecl fielddecl_; IdentifierLabel identifierlabel_; } e_;
  } u;
};

StructDecl make_E(IdentifierLabel p0, FieldDecl p1);

struct FieldDecl_
{
  enum { is_F } kind;
  union
  {
    struct { IdentifierLabel identifierlabel_; TypeType typetype_; } f_;
  } u;
};

FieldDecl make_F(TypeType p0, IdentifierLabel p1);

struct PonteiraDecl_
{
  enum { is_P } kind;
  union
  {
    struct { IdentifierLabel identifierlabel_; TypeType typetype_; } p_;
  } u;
};

PonteiraDecl make_P(TypeType p0, IdentifierLabel p1);

struct VetorDecl_
{
  enum { is_V } kind;
  union
  {
    struct { IdentifierLabel identifierlabel_; Inteiro inteiro_; TypeType typetype_; } v_;
  } u;
};

VetorDecl make_V(TypeType p0, IdentifierLabel p1, Inteiro p2);

struct Instrucoes_
{
  enum { is_Instrucoes1 } kind;
  union
  {
    struct { Instrucao instrucao_; Instrucoes instrucoes_; } instrucoes1_;
  } u;
};

Instrucoes make_Instrucoes1(Instrucao p0, Instrucoes p1);

struct Instrucao_
{
  enum { is_Instrucao1, is_Instrucao2 } kind;
  union
  {
    struct { Atribuicao atribuicao_; } instrucao1_;
    struct { Modularizacao modularizacao_; } instrucao2_;
  } u;
};

Instrucao make_Instrucao1(Atribuicao p0);
Instrucao make_Instrucao2(Modularizacao p0);

struct Atribuicao_
{
  enum { is_A } kind;
  union
  {
    struct { Expressao expressao_; Identificador identificador_; } a_;
  } u;
};

Atribuicao make_A(Identificador p0, Expressao p1);

struct Comentario_
{
  enum { is_Co } kind;
  union
  {
    struct { String string_; } co_;
  } u;
};

Comentario make_Co(String p0);

struct DeclaracaoSe_
{
  enum { is_Label2 } kind;
  union
  {
    struct { Expressao expressao_; Instrucoes instrucoes_1, instrucoes_2; } label2_;
  } u;
};

DeclaracaoSe make_Label2(Expressao p0, Instrucoes p1, Instrucoes p2);

struct LoopPara_
{
  enum { is_Label3 } kind;
  union
  {
    struct { Atribuicao atribuicao_1, atribuicao_2; Condicao condicao_; Instrucoes instrucoes_; } label3_;
  } u;
};

LoopPara make_Label3(Atribuicao p0, Condicao p1, Atribuicao p2, Instrucoes p3);

struct Imprima_
{
  enum { is_Label4 } kind;
  union
  {
    struct { Expressao expressao_; } label4_;
  } u;
};

Imprima make_Label4(Expressao p0);

struct Entrada_
{
  enum { is_Label5 } kind;
  union
  {
    struct { Identificador identificador_; } label5_;
  } u;
};

Entrada make_Label5(Identificador p0);

struct Modularizacao_
{
  enum { is_Label6 } kind;
  union
  {
    struct { IdentifierLabel identifierlabel_; Instrucoes instrucoes_; } label6_;
  } u;
};

Modularizacao make_Label6(IdentifierLabel p0, Instrucoes p1);

struct Expressao_
{
  enum { is_Expressao1, is_Expressao2, is_Expressao3, is_Expressao4, is_Expressao5 } kind;
  union
  {
    struct { Termo termo_; } expressao1_;
    struct { Expressao expressao_; Termo termo_; } expressao2_;
    struct { Expressao expressao_; Termo termo_; } expressao3_;
    struct { Expressao expressao_; Termo termo_; } expressao4_;
    struct { Expressao expressao_; Termo termo_; } expressao5_;
  } u;
};

Expressao make_Expressao1(Termo p0);
Expressao make_Expressao2(Expressao p0, Termo p1);
Expressao make_Expressao3(Expressao p0, Termo p1);
Expressao make_Expressao4(Expressao p0, Termo p1);
Expressao make_Expressao5(Expressao p0, Termo p1);

struct Termo_
{
  enum { is_Termo1, is_Termo2, is_TermoInteiro, is_TermoTexto, is_Termo3 } kind;
  union
  {
    struct { Identificador identificador_; } termo1_;
    struct { Identificador identificador_; Inteiro inteiro_; } termo2_;
    struct { Inteiro inteiro_; } termointeiro_;
    struct { Texto texto_; } termotexto_;
    struct { Identificador identificador_; Inteiro inteiro_; } termo3_;
  } u;
};

Termo make_Termo1(Identificador p0);
Termo make_Termo2(Identificador p0, Inteiro p1);
Termo make_TermoInteiro(Inteiro p0);
Termo make_TermoTexto(Texto p0);
Termo make_Termo3(Identificador p0, Inteiro p1);

struct Condicao_
{
  enum { is_Condicao1, is_Condicao2, is_Condicao3, is_Condicao4, is_Condicao5, is_Condicao6, is_Condicao7, is_Condicao8, is_Condicao9 } kind;
  union
  {
    struct { Expressao expressao_1, expressao_2; } condicao1_;
    struct { Expressao expressao_1, expressao_2; } condicao2_;
    struct { Expressao expressao_1, expressao_2; } condicao3_;
    struct { Expressao expressao_1, expressao_2; } condicao4_;
    struct { Expressao expressao_1, expressao_2; } condicao5_;
    struct { Condicao condicao_; } condicao6_;
    struct { Condicao condicao_; } condicao7_;
    struct { Condicao condicao_1, condicao_2; } condicao8_;
    struct { Condicao condicao_1, condicao_2; } condicao9_;
  } u;
};

Condicao make_Condicao1(Expressao p0, Expressao p1);
Condicao make_Condicao2(Expressao p0, Expressao p1);
Condicao make_Condicao3(Expressao p0, Expressao p1);
Condicao make_Condicao4(Expressao p0, Expressao p1);
Condicao make_Condicao5(Expressao p0, Expressao p1);
Condicao make_Condicao6(Condicao p0);
Condicao make_Condicao7(Condicao p0);
Condicao make_Condicao8(Condicao p0, Condicao p1);
Condicao make_Condicao9(Condicao p0, Condicao p1);

struct Tipo_
{
  enum { is_Tipo_int, is_Tipo_texto, is_Tipo1 } kind;
  union
  {
    struct { IdentifierLabel identifierlabel_; } tipo1_;
  } u;
};

Tipo make_Tipo_int(void);
Tipo make_Tipo_texto(void);
Tipo make_Tipo1(IdentifierLabel p0);

struct Identificador_
{
  enum { is_Id } kind;
  union
  {
    struct { Letra letra_; } id_;
  } u;
};

Identificador make_Id(Letra p0);

struct Inteiro_
{
  enum { is_In } kind;
  union
  {
    struct { Digito digito_; } in_;
  } u;
};

Inteiro make_In(Digito p0);

struct Real_
{
  enum { is_Ir } kind;
  union
  {
    struct { Digito digito_1, digito_2; } ir_;
  } u;
};

Real make_Ir(Digito p0, Digito p1);

struct Chax_
{
  enum { is_Ch } kind;
  union
  {
    struct { Letra letra_; } ch_;
  } u;
};

Chax make_Ch(Letra p0);

struct Texto_
{
  enum { is_It } kind;
  union
  {
  } u;
};

Texto make_It(void);

struct IdentifierLabel_
{
  enum { is_Ie } kind;
  union
  {
    struct { Identificador identificador_; } ie_;
  } u;
};

IdentifierLabel make_Ie(Identificador p0);

struct TypeType_
{
  enum { is_TypeType11, is_TypeType12, is_TypeType13, is_TypeType21, is_TypeType22, is_TypeType23, is_TypeType31, is_TypeType32, is_TypeType33 } kind;
  union
  {
    struct { IdentifierLabel identifierlabel_; } typetype13_;
    struct { IdentifierLabel identifierlabel_; } typetype23_;
    struct { IdentifierLabel identifierlabel_; } typetype33_;
  } u;
};

TypeType make_TypeType11(void);
TypeType make_TypeType12(void);
TypeType make_TypeType13(IdentifierLabel p0);
TypeType make_TypeType21(void);
TypeType make_TypeType22(void);
TypeType make_TypeType23(IdentifierLabel p0);
TypeType make_TypeType31(void);
TypeType make_TypeType32(void);
TypeType make_TypeType33(IdentifierLabel p0);

struct Letra_
{
  enum { is_L } kind;
  union
  {
  } u;
};

Letra make_L(void);

struct Digito_
{
  enum { is_D } kind;
  union
  {
  } u;
};

Digito make_D(void);

struct Caractere_
{
  enum { is_Ca } kind;
  union
  {
  } u;
};

Caractere make_Ca(void);

/***************************   Cloning   ******************************/

Programs clone_Programs(Programs p);
Declaracoes clone_Declaracoes(Declaracoes p);
Declaracao clone_Declaracao(Declaracao p);
StructDecl clone_StructDecl(StructDecl p);
FieldDecl clone_FieldDecl(FieldDecl p);
PonteiraDecl clone_PonteiraDecl(PonteiraDecl p);
VetorDecl clone_VetorDecl(VetorDecl p);
Instrucoes clone_Instrucoes(Instrucoes p);
Instrucao clone_Instrucao(Instrucao p);
Atribuicao clone_Atribuicao(Atribuicao p);
Comentario clone_Comentario(Comentario p);
DeclaracaoSe clone_DeclaracaoSe(DeclaracaoSe p);
LoopPara clone_LoopPara(LoopPara p);
Imprima clone_Imprima(Imprima p);
Entrada clone_Entrada(Entrada p);
Modularizacao clone_Modularizacao(Modularizacao p);
Expressao clone_Expressao(Expressao p);
Termo clone_Termo(Termo p);
Condicao clone_Condicao(Condicao p);
Tipo clone_Tipo(Tipo p);
Identificador clone_Identificador(Identificador p);
Inteiro clone_Inteiro(Inteiro p);
Real clone_Real(Real p);
Chax clone_Chax(Chax p);
Texto clone_Texto(Texto p);
IdentifierLabel clone_IdentifierLabel(IdentifierLabel p);
TypeType clone_TypeType(TypeType p);
Letra clone_Letra(Letra p);
Digito clone_Digito(Digito p);
Caractere clone_Caractere(Caractere p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Programs(Programs p);
void free_Declaracoes(Declaracoes p);
void free_Declaracao(Declaracao p);
void free_StructDecl(StructDecl p);
void free_FieldDecl(FieldDecl p);
void free_PonteiraDecl(PonteiraDecl p);
void free_VetorDecl(VetorDecl p);
void free_Instrucoes(Instrucoes p);
void free_Instrucao(Instrucao p);
void free_Atribuicao(Atribuicao p);
void free_Comentario(Comentario p);
void free_DeclaracaoSe(DeclaracaoSe p);
void free_LoopPara(LoopPara p);
void free_Imprima(Imprima p);
void free_Entrada(Entrada p);
void free_Modularizacao(Modularizacao p);
void free_Expressao(Expressao p);
void free_Termo(Termo p);
void free_Condicao(Condicao p);
void free_Tipo(Tipo p);
void free_Identificador(Identificador p);
void free_Inteiro(Inteiro p);
void free_Real(Real p);
void free_Chax(Chax p);
void free_Texto(Texto p);
void free_IdentifierLabel(IdentifierLabel p);
void free_TypeType(TypeType p);
void free_Letra(Letra p);
void free_Digito(Digito p);
void free_Caractere(Caractere p);


#endif
